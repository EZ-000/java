# Ch5 재귀란?

## 5.1 재귀

메서드 호출을 이용한 방법으로, 하나의 메서드 내에서 자기 자신을 호출하도록 하여 반복적인 개념을 구현하는 것



 ### 재귀의 최대 범위와 한계점

재귀 호출은 반복 작업을 구현하는 것이기 때문에 재귀의 호출 횟수가 시간 복잡도에 직접적으로 영향

재귀 호출을 하면 호출된 메서드에서 사용할 변수들은 메모리에 추가 할당됨. 이렇게 메모리가 할당된 변수들은 해당 재귀 호출이 종료되어 더 이상 참조하지 않게 되었을 때 자동으로 메모리에서 할당이 해제됨

재귀 호출이 중간에 종료되지 않고 너무 깊게 들어가 버리면 변수들이 메모리를 모두 할당해서 StackOverflowError 예외가 발생

이런 예외를 발생시키지 않으려면 재귀 호출의 깊이를 안전하게는 10,000 이하, 아무리 많아도 20,000 이하로 유지시켜야 함



## 5.2 재귀 정의하기

#### 1. 상태 정의하기

답을 결정하는 변수인 상태를 정의

#### 2. 종료 조건

**재귀**

하나의 문제를 부분 문제들로 나누거나 부분 문제의 답을 이용하여 원본 문제의 답을 찾아야 풀 수 있음

부분 문제는 상태에 대한 답을 찾는 것이므로 부분 문제가 나타나는 상태는 재귀가 진행될수록 점점 작아져, 결국 이어지는 부분 문제 없이 즉시 답이 나와야 함

**종료 조건** 

즉시 답이 나오는 상태를 검사하여 답을 반환할 수 있도록 하는 것

#### 3. 점화식

상태와 종료 조건을 정의한 후에는 가장 큰 상태가 어떤 과정을 거쳐 가장 작은 상태인 종료 조건에 도달하는지 정의해야 함

부분 문제는 같은 규칙으로 더 작은 부분 문제로 진행되어야 함. 따라서 상태 또한 하나의 규칙으로 더 작은 상태로 전이되어야 

**점화식**

상태를 전이시키는 규칙



## 5.3 코드 작성하기

#### 1. 부분 문제 나타내기

```java
private int power(int n, int m) {
    // 종료 조건, 점화식 구현하기
}
```

#### 2. 종료 조건 작성하기

```java
private int power(int n, int m) {
    if (m == 0) return 1;
    if (n == 1) return 1;
    if (n == 0) return 1;
    
    // 점화식 구현하기
}
```

#### 3. 점화식 구현하기

```java
private int power(int n, int m) {
    if (m == 0) return 1;
    if (n == 1) return 1;
    if (n == 0) return 1;
 
    return n * power(n, m - 1);
}
```

